Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    NE
    PLUS
    POWER
    RETURN
    STRING
    TIMES

Grammar

Rule 0     S' -> program
Rule 1     program -> program statement
Rule 2     program -> statement
Rule 3     statement -> random_var_assignment SEMI
Rule 4     statement -> numeric_var_assignment SEMI
Rule 5     statement -> ifblock
Rule 6     statement -> ifelseblock
Rule 7     statement -> statement NEWLINE
Rule 8     random_var_assignment -> RANDOM variable EQUALS gaussfunc
Rule 9     numeric_var_assignment -> NUMERIC variable EQUALS number
Rule 10    gaussfunc -> GAUSS LPAREN EPS DIVIDE number COMMA variable RPAREN
Rule 11    gaussfunc -> GAUSS LPAREN EPS DIVIDE number COMMA number RPAREN
Rule 12    ifblock -> IF boolean THEN LCURLY NEWLINE program NEWLINE RCURLY
Rule 13    ifelseblock -> IF boolean THEN LCURLY NEWLINE program RCURLY ELSE LCURLY NEWLINE program RCURLY
Rule 14    variable -> ID
Rule 15    number -> INTEGER
Rule 16    number -> FLOAT
Rule 17    number -> MINUS INTEGER
Rule 18    number -> MINUS FLOAT
Rule 19    boolean -> TRUE
Rule 20    boolean -> FALSE
Rule 21    boolean -> variable GT variable
Rule 22    boolean -> variable GE variable
Rule 23    boolean -> variable LE variable
Rule 24    boolean -> variable LT variable
Rule 25    boolean -> boolean AND boolean
Rule 26    boolean -> boolean OR boolean
Rule 27    boolean -> NOT boolean

Terminals, with rules where they appear

AND                  : 25
COMMA                : 10 11
DIVIDE               : 10 11
ELSE                 : 13
EPS                  : 10 11
EQUALS               : 8 9
FALSE                : 20
FLOAT                : 16 18
GAUSS                : 10 11
GE                   : 22
GT                   : 21
ID                   : 14
IF                   : 12 13
INTEGER              : 15 17
LCURLY               : 12 13 13
LE                   : 23
LPAREN               : 10 11
LT                   : 24
MINUS                : 17 18
NE                   : 
NEWLINE              : 7 12 12 13 13
NOT                  : 27
NUMERIC              : 9
OR                   : 26
PLUS                 : 
POWER                : 
RANDOM               : 8
RCURLY               : 12 13 13
RETURN               : 
RPAREN               : 10 11
SEMI                 : 3 4
STRING               : 
THEN                 : 12 13
TIMES                : 
TRUE                 : 19
error                : 

Nonterminals, with rules where they appear

boolean              : 12 13 25 25 26 26 27
gaussfunc            : 8
ifblock              : 5
ifelseblock          : 6
number               : 9 10 11 11
numeric_var_assignment : 4
program              : 1 12 13 13 0
random_var_assignment : 3
statement            : 1 2 7
variable             : 8 9 10 21 21 22 22 23 23 24 24

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . program statement
    (2) program -> . statement
    (3) statement -> . random_var_assignment SEMI
    (4) statement -> . numeric_var_assignment SEMI
    (5) statement -> . ifblock
    (6) statement -> . ifelseblock
    (7) statement -> . statement NEWLINE
    (8) random_var_assignment -> . RANDOM variable EQUALS gaussfunc
    (9) numeric_var_assignment -> . NUMERIC variable EQUALS number
    (12) ifblock -> . IF boolean THEN LCURLY NEWLINE program NEWLINE RCURLY
    (13) ifelseblock -> . IF boolean THEN LCURLY NEWLINE program RCURLY ELSE LCURLY NEWLINE program RCURLY

    RANDOM          shift and go to state 7
    NUMERIC         shift and go to state 8
    IF              shift and go to state 9

    program                        shift and go to state 1
    statement                      shift and go to state 2
    random_var_assignment          shift and go to state 3
    numeric_var_assignment         shift and go to state 4
    ifblock                        shift and go to state 5
    ifelseblock                    shift and go to state 6

state 1

    (0) S' -> program .
    (1) program -> program . statement
    (3) statement -> . random_var_assignment SEMI
    (4) statement -> . numeric_var_assignment SEMI
    (5) statement -> . ifblock
    (6) statement -> . ifelseblock
    (7) statement -> . statement NEWLINE
    (8) random_var_assignment -> . RANDOM variable EQUALS gaussfunc
    (9) numeric_var_assignment -> . NUMERIC variable EQUALS number
    (12) ifblock -> . IF boolean THEN LCURLY NEWLINE program NEWLINE RCURLY
    (13) ifelseblock -> . IF boolean THEN LCURLY NEWLINE program RCURLY ELSE LCURLY NEWLINE program RCURLY

    RANDOM          shift and go to state 7
    NUMERIC         shift and go to state 8
    IF              shift and go to state 9

    statement                      shift and go to state 10
    random_var_assignment          shift and go to state 3
    numeric_var_assignment         shift and go to state 4
    ifblock                        shift and go to state 5
    ifelseblock                    shift and go to state 6

state 2

    (2) program -> statement .
    (7) statement -> statement . NEWLINE

  ! shift/reduce conflict for NEWLINE resolved as shift
    RANDOM          reduce using rule 2 (program -> statement .)
    NUMERIC         reduce using rule 2 (program -> statement .)
    IF              reduce using rule 2 (program -> statement .)
    $end            reduce using rule 2 (program -> statement .)
    RCURLY          reduce using rule 2 (program -> statement .)
    NEWLINE         shift and go to state 11

  ! NEWLINE         [ reduce using rule 2 (program -> statement .) ]


state 3

    (3) statement -> random_var_assignment . SEMI

    SEMI            shift and go to state 12


state 4

    (4) statement -> numeric_var_assignment . SEMI

    SEMI            shift and go to state 13


state 5

    (5) statement -> ifblock .

    NEWLINE         reduce using rule 5 (statement -> ifblock .)
    RANDOM          reduce using rule 5 (statement -> ifblock .)
    NUMERIC         reduce using rule 5 (statement -> ifblock .)
    IF              reduce using rule 5 (statement -> ifblock .)
    $end            reduce using rule 5 (statement -> ifblock .)
    RCURLY          reduce using rule 5 (statement -> ifblock .)


state 6

    (6) statement -> ifelseblock .

    NEWLINE         reduce using rule 6 (statement -> ifelseblock .)
    RANDOM          reduce using rule 6 (statement -> ifelseblock .)
    NUMERIC         reduce using rule 6 (statement -> ifelseblock .)
    IF              reduce using rule 6 (statement -> ifelseblock .)
    $end            reduce using rule 6 (statement -> ifelseblock .)
    RCURLY          reduce using rule 6 (statement -> ifelseblock .)


state 7

    (8) random_var_assignment -> RANDOM . variable EQUALS gaussfunc
    (14) variable -> . ID

    ID              shift and go to state 15

    variable                       shift and go to state 14

state 8

    (9) numeric_var_assignment -> NUMERIC . variable EQUALS number
    (14) variable -> . ID

    ID              shift and go to state 15

    variable                       shift and go to state 16

state 9

    (12) ifblock -> IF . boolean THEN LCURLY NEWLINE program NEWLINE RCURLY
    (13) ifelseblock -> IF . boolean THEN LCURLY NEWLINE program RCURLY ELSE LCURLY NEWLINE program RCURLY
    (19) boolean -> . TRUE
    (20) boolean -> . FALSE
    (21) boolean -> . variable GT variable
    (22) boolean -> . variable GE variable
    (23) boolean -> . variable LE variable
    (24) boolean -> . variable LT variable
    (25) boolean -> . boolean AND boolean
    (26) boolean -> . boolean OR boolean
    (27) boolean -> . NOT boolean
    (14) variable -> . ID

    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    NOT             shift and go to state 21
    ID              shift and go to state 15

    boolean                        shift and go to state 17
    variable                       shift and go to state 20

state 10

    (1) program -> program statement .
    (7) statement -> statement . NEWLINE

  ! shift/reduce conflict for NEWLINE resolved as shift
    RANDOM          reduce using rule 1 (program -> program statement .)
    NUMERIC         reduce using rule 1 (program -> program statement .)
    IF              reduce using rule 1 (program -> program statement .)
    $end            reduce using rule 1 (program -> program statement .)
    RCURLY          reduce using rule 1 (program -> program statement .)
    NEWLINE         shift and go to state 11

  ! NEWLINE         [ reduce using rule 1 (program -> program statement .) ]


state 11

    (7) statement -> statement NEWLINE .

    NEWLINE         reduce using rule 7 (statement -> statement NEWLINE .)
    RANDOM          reduce using rule 7 (statement -> statement NEWLINE .)
    NUMERIC         reduce using rule 7 (statement -> statement NEWLINE .)
    IF              reduce using rule 7 (statement -> statement NEWLINE .)
    $end            reduce using rule 7 (statement -> statement NEWLINE .)
    RCURLY          reduce using rule 7 (statement -> statement NEWLINE .)


state 12

    (3) statement -> random_var_assignment SEMI .

    NEWLINE         reduce using rule 3 (statement -> random_var_assignment SEMI .)
    RANDOM          reduce using rule 3 (statement -> random_var_assignment SEMI .)
    NUMERIC         reduce using rule 3 (statement -> random_var_assignment SEMI .)
    IF              reduce using rule 3 (statement -> random_var_assignment SEMI .)
    $end            reduce using rule 3 (statement -> random_var_assignment SEMI .)
    RCURLY          reduce using rule 3 (statement -> random_var_assignment SEMI .)


state 13

    (4) statement -> numeric_var_assignment SEMI .

    NEWLINE         reduce using rule 4 (statement -> numeric_var_assignment SEMI .)
    RANDOM          reduce using rule 4 (statement -> numeric_var_assignment SEMI .)
    NUMERIC         reduce using rule 4 (statement -> numeric_var_assignment SEMI .)
    IF              reduce using rule 4 (statement -> numeric_var_assignment SEMI .)
    $end            reduce using rule 4 (statement -> numeric_var_assignment SEMI .)
    RCURLY          reduce using rule 4 (statement -> numeric_var_assignment SEMI .)


state 14

    (8) random_var_assignment -> RANDOM variable . EQUALS gaussfunc

    EQUALS          shift and go to state 22


state 15

    (14) variable -> ID .

    EQUALS          reduce using rule 14 (variable -> ID .)
    GT              reduce using rule 14 (variable -> ID .)
    GE              reduce using rule 14 (variable -> ID .)
    LE              reduce using rule 14 (variable -> ID .)
    LT              reduce using rule 14 (variable -> ID .)
    THEN            reduce using rule 14 (variable -> ID .)
    AND             reduce using rule 14 (variable -> ID .)
    OR              reduce using rule 14 (variable -> ID .)
    RPAREN          reduce using rule 14 (variable -> ID .)


state 16

    (9) numeric_var_assignment -> NUMERIC variable . EQUALS number

    EQUALS          shift and go to state 23


state 17

    (12) ifblock -> IF boolean . THEN LCURLY NEWLINE program NEWLINE RCURLY
    (13) ifelseblock -> IF boolean . THEN LCURLY NEWLINE program RCURLY ELSE LCURLY NEWLINE program RCURLY
    (25) boolean -> boolean . AND boolean
    (26) boolean -> boolean . OR boolean

    THEN            shift and go to state 24
    AND             shift and go to state 25
    OR              shift and go to state 26


state 18

    (19) boolean -> TRUE .

    THEN            reduce using rule 19 (boolean -> TRUE .)
    AND             reduce using rule 19 (boolean -> TRUE .)
    OR              reduce using rule 19 (boolean -> TRUE .)


state 19

    (20) boolean -> FALSE .

    THEN            reduce using rule 20 (boolean -> FALSE .)
    AND             reduce using rule 20 (boolean -> FALSE .)
    OR              reduce using rule 20 (boolean -> FALSE .)


state 20

    (21) boolean -> variable . GT variable
    (22) boolean -> variable . GE variable
    (23) boolean -> variable . LE variable
    (24) boolean -> variable . LT variable

    GT              shift and go to state 27
    GE              shift and go to state 28
    LE              shift and go to state 29
    LT              shift and go to state 30


state 21

    (27) boolean -> NOT . boolean
    (19) boolean -> . TRUE
    (20) boolean -> . FALSE
    (21) boolean -> . variable GT variable
    (22) boolean -> . variable GE variable
    (23) boolean -> . variable LE variable
    (24) boolean -> . variable LT variable
    (25) boolean -> . boolean AND boolean
    (26) boolean -> . boolean OR boolean
    (27) boolean -> . NOT boolean
    (14) variable -> . ID

    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    NOT             shift and go to state 21
    ID              shift and go to state 15

    boolean                        shift and go to state 31
    variable                       shift and go to state 20

state 22

    (8) random_var_assignment -> RANDOM variable EQUALS . gaussfunc
    (10) gaussfunc -> . GAUSS LPAREN EPS DIVIDE number COMMA variable RPAREN
    (11) gaussfunc -> . GAUSS LPAREN EPS DIVIDE number COMMA number RPAREN

    GAUSS           shift and go to state 33

    gaussfunc                      shift and go to state 32

state 23

    (9) numeric_var_assignment -> NUMERIC variable EQUALS . number
    (15) number -> . INTEGER
    (16) number -> . FLOAT
    (17) number -> . MINUS INTEGER
    (18) number -> . MINUS FLOAT

    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    MINUS           shift and go to state 37

    number                         shift and go to state 34

state 24

    (12) ifblock -> IF boolean THEN . LCURLY NEWLINE program NEWLINE RCURLY
    (13) ifelseblock -> IF boolean THEN . LCURLY NEWLINE program RCURLY ELSE LCURLY NEWLINE program RCURLY

    LCURLY          shift and go to state 38


state 25

    (25) boolean -> boolean AND . boolean
    (19) boolean -> . TRUE
    (20) boolean -> . FALSE
    (21) boolean -> . variable GT variable
    (22) boolean -> . variable GE variable
    (23) boolean -> . variable LE variable
    (24) boolean -> . variable LT variable
    (25) boolean -> . boolean AND boolean
    (26) boolean -> . boolean OR boolean
    (27) boolean -> . NOT boolean
    (14) variable -> . ID

    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    NOT             shift and go to state 21
    ID              shift and go to state 15

    boolean                        shift and go to state 39
    variable                       shift and go to state 20

state 26

    (26) boolean -> boolean OR . boolean
    (19) boolean -> . TRUE
    (20) boolean -> . FALSE
    (21) boolean -> . variable GT variable
    (22) boolean -> . variable GE variable
    (23) boolean -> . variable LE variable
    (24) boolean -> . variable LT variable
    (25) boolean -> . boolean AND boolean
    (26) boolean -> . boolean OR boolean
    (27) boolean -> . NOT boolean
    (14) variable -> . ID

    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    NOT             shift and go to state 21
    ID              shift and go to state 15

    boolean                        shift and go to state 40
    variable                       shift and go to state 20

state 27

    (21) boolean -> variable GT . variable
    (14) variable -> . ID

    ID              shift and go to state 15

    variable                       shift and go to state 41

state 28

    (22) boolean -> variable GE . variable
    (14) variable -> . ID

    ID              shift and go to state 15

    variable                       shift and go to state 42

state 29

    (23) boolean -> variable LE . variable
    (14) variable -> . ID

    ID              shift and go to state 15

    variable                       shift and go to state 43

state 30

    (24) boolean -> variable LT . variable
    (14) variable -> . ID

    ID              shift and go to state 15

    variable                       shift and go to state 44

state 31

    (27) boolean -> NOT boolean .
    (25) boolean -> boolean . AND boolean
    (26) boolean -> boolean . OR boolean

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    THEN            reduce using rule 27 (boolean -> NOT boolean .)
    AND             shift and go to state 25
    OR              shift and go to state 26

  ! AND             [ reduce using rule 27 (boolean -> NOT boolean .) ]
  ! OR              [ reduce using rule 27 (boolean -> NOT boolean .) ]


state 32

    (8) random_var_assignment -> RANDOM variable EQUALS gaussfunc .

    SEMI            reduce using rule 8 (random_var_assignment -> RANDOM variable EQUALS gaussfunc .)


state 33

    (10) gaussfunc -> GAUSS . LPAREN EPS DIVIDE number COMMA variable RPAREN
    (11) gaussfunc -> GAUSS . LPAREN EPS DIVIDE number COMMA number RPAREN

    LPAREN          shift and go to state 45


state 34

    (9) numeric_var_assignment -> NUMERIC variable EQUALS number .

    SEMI            reduce using rule 9 (numeric_var_assignment -> NUMERIC variable EQUALS number .)


state 35

    (15) number -> INTEGER .

    SEMI            reduce using rule 15 (number -> INTEGER .)
    COMMA           reduce using rule 15 (number -> INTEGER .)
    RPAREN          reduce using rule 15 (number -> INTEGER .)


state 36

    (16) number -> FLOAT .

    SEMI            reduce using rule 16 (number -> FLOAT .)
    COMMA           reduce using rule 16 (number -> FLOAT .)
    RPAREN          reduce using rule 16 (number -> FLOAT .)


state 37

    (17) number -> MINUS . INTEGER
    (18) number -> MINUS . FLOAT

    INTEGER         shift and go to state 46
    FLOAT           shift and go to state 47


state 38

    (12) ifblock -> IF boolean THEN LCURLY . NEWLINE program NEWLINE RCURLY
    (13) ifelseblock -> IF boolean THEN LCURLY . NEWLINE program RCURLY ELSE LCURLY NEWLINE program RCURLY

    NEWLINE         shift and go to state 48


state 39

    (25) boolean -> boolean AND boolean .
    (25) boolean -> boolean . AND boolean
    (26) boolean -> boolean . OR boolean

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    THEN            reduce using rule 25 (boolean -> boolean AND boolean .)
    AND             shift and go to state 25
    OR              shift and go to state 26

  ! AND             [ reduce using rule 25 (boolean -> boolean AND boolean .) ]
  ! OR              [ reduce using rule 25 (boolean -> boolean AND boolean .) ]


state 40

    (26) boolean -> boolean OR boolean .
    (25) boolean -> boolean . AND boolean
    (26) boolean -> boolean . OR boolean

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    THEN            reduce using rule 26 (boolean -> boolean OR boolean .)
    AND             shift and go to state 25
    OR              shift and go to state 26

  ! AND             [ reduce using rule 26 (boolean -> boolean OR boolean .) ]
  ! OR              [ reduce using rule 26 (boolean -> boolean OR boolean .) ]


state 41

    (21) boolean -> variable GT variable .

    THEN            reduce using rule 21 (boolean -> variable GT variable .)
    AND             reduce using rule 21 (boolean -> variable GT variable .)
    OR              reduce using rule 21 (boolean -> variable GT variable .)


state 42

    (22) boolean -> variable GE variable .

    THEN            reduce using rule 22 (boolean -> variable GE variable .)
    AND             reduce using rule 22 (boolean -> variable GE variable .)
    OR              reduce using rule 22 (boolean -> variable GE variable .)


state 43

    (23) boolean -> variable LE variable .

    THEN            reduce using rule 23 (boolean -> variable LE variable .)
    AND             reduce using rule 23 (boolean -> variable LE variable .)
    OR              reduce using rule 23 (boolean -> variable LE variable .)


state 44

    (24) boolean -> variable LT variable .

    THEN            reduce using rule 24 (boolean -> variable LT variable .)
    AND             reduce using rule 24 (boolean -> variable LT variable .)
    OR              reduce using rule 24 (boolean -> variable LT variable .)


state 45

    (10) gaussfunc -> GAUSS LPAREN . EPS DIVIDE number COMMA variable RPAREN
    (11) gaussfunc -> GAUSS LPAREN . EPS DIVIDE number COMMA number RPAREN

    EPS             shift and go to state 49


state 46

    (17) number -> MINUS INTEGER .

    SEMI            reduce using rule 17 (number -> MINUS INTEGER .)
    COMMA           reduce using rule 17 (number -> MINUS INTEGER .)
    RPAREN          reduce using rule 17 (number -> MINUS INTEGER .)


state 47

    (18) number -> MINUS FLOAT .

    SEMI            reduce using rule 18 (number -> MINUS FLOAT .)
    COMMA           reduce using rule 18 (number -> MINUS FLOAT .)
    RPAREN          reduce using rule 18 (number -> MINUS FLOAT .)


state 48

    (12) ifblock -> IF boolean THEN LCURLY NEWLINE . program NEWLINE RCURLY
    (13) ifelseblock -> IF boolean THEN LCURLY NEWLINE . program RCURLY ELSE LCURLY NEWLINE program RCURLY
    (1) program -> . program statement
    (2) program -> . statement
    (3) statement -> . random_var_assignment SEMI
    (4) statement -> . numeric_var_assignment SEMI
    (5) statement -> . ifblock
    (6) statement -> . ifelseblock
    (7) statement -> . statement NEWLINE
    (8) random_var_assignment -> . RANDOM variable EQUALS gaussfunc
    (9) numeric_var_assignment -> . NUMERIC variable EQUALS number
    (12) ifblock -> . IF boolean THEN LCURLY NEWLINE program NEWLINE RCURLY
    (13) ifelseblock -> . IF boolean THEN LCURLY NEWLINE program RCURLY ELSE LCURLY NEWLINE program RCURLY

    RANDOM          shift and go to state 7
    NUMERIC         shift and go to state 8
    IF              shift and go to state 9

    program                        shift and go to state 50
    statement                      shift and go to state 2
    random_var_assignment          shift and go to state 3
    numeric_var_assignment         shift and go to state 4
    ifblock                        shift and go to state 5
    ifelseblock                    shift and go to state 6

state 49

    (10) gaussfunc -> GAUSS LPAREN EPS . DIVIDE number COMMA variable RPAREN
    (11) gaussfunc -> GAUSS LPAREN EPS . DIVIDE number COMMA number RPAREN

    DIVIDE          shift and go to state 51


state 50

    (12) ifblock -> IF boolean THEN LCURLY NEWLINE program . NEWLINE RCURLY
    (13) ifelseblock -> IF boolean THEN LCURLY NEWLINE program . RCURLY ELSE LCURLY NEWLINE program RCURLY
    (1) program -> program . statement
    (3) statement -> . random_var_assignment SEMI
    (4) statement -> . numeric_var_assignment SEMI
    (5) statement -> . ifblock
    (6) statement -> . ifelseblock
    (7) statement -> . statement NEWLINE
    (8) random_var_assignment -> . RANDOM variable EQUALS gaussfunc
    (9) numeric_var_assignment -> . NUMERIC variable EQUALS number
    (12) ifblock -> . IF boolean THEN LCURLY NEWLINE program NEWLINE RCURLY
    (13) ifelseblock -> . IF boolean THEN LCURLY NEWLINE program RCURLY ELSE LCURLY NEWLINE program RCURLY

    NEWLINE         shift and go to state 52
    RCURLY          shift and go to state 53
    RANDOM          shift and go to state 7
    NUMERIC         shift and go to state 8
    IF              shift and go to state 9

    statement                      shift and go to state 10
    random_var_assignment          shift and go to state 3
    numeric_var_assignment         shift and go to state 4
    ifblock                        shift and go to state 5
    ifelseblock                    shift and go to state 6

state 51

    (10) gaussfunc -> GAUSS LPAREN EPS DIVIDE . number COMMA variable RPAREN
    (11) gaussfunc -> GAUSS LPAREN EPS DIVIDE . number COMMA number RPAREN
    (15) number -> . INTEGER
    (16) number -> . FLOAT
    (17) number -> . MINUS INTEGER
    (18) number -> . MINUS FLOAT

    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    MINUS           shift and go to state 37

    number                         shift and go to state 54

state 52

    (12) ifblock -> IF boolean THEN LCURLY NEWLINE program NEWLINE . RCURLY

    RCURLY          shift and go to state 55


state 53

    (13) ifelseblock -> IF boolean THEN LCURLY NEWLINE program RCURLY . ELSE LCURLY NEWLINE program RCURLY

    ELSE            shift and go to state 56


state 54

    (10) gaussfunc -> GAUSS LPAREN EPS DIVIDE number . COMMA variable RPAREN
    (11) gaussfunc -> GAUSS LPAREN EPS DIVIDE number . COMMA number RPAREN

    COMMA           shift and go to state 57


state 55

    (12) ifblock -> IF boolean THEN LCURLY NEWLINE program NEWLINE RCURLY .

    NEWLINE         reduce using rule 12 (ifblock -> IF boolean THEN LCURLY NEWLINE program NEWLINE RCURLY .)
    RANDOM          reduce using rule 12 (ifblock -> IF boolean THEN LCURLY NEWLINE program NEWLINE RCURLY .)
    NUMERIC         reduce using rule 12 (ifblock -> IF boolean THEN LCURLY NEWLINE program NEWLINE RCURLY .)
    IF              reduce using rule 12 (ifblock -> IF boolean THEN LCURLY NEWLINE program NEWLINE RCURLY .)
    $end            reduce using rule 12 (ifblock -> IF boolean THEN LCURLY NEWLINE program NEWLINE RCURLY .)
    RCURLY          reduce using rule 12 (ifblock -> IF boolean THEN LCURLY NEWLINE program NEWLINE RCURLY .)


state 56

    (13) ifelseblock -> IF boolean THEN LCURLY NEWLINE program RCURLY ELSE . LCURLY NEWLINE program RCURLY

    LCURLY          shift and go to state 58


state 57

    (10) gaussfunc -> GAUSS LPAREN EPS DIVIDE number COMMA . variable RPAREN
    (11) gaussfunc -> GAUSS LPAREN EPS DIVIDE number COMMA . number RPAREN
    (14) variable -> . ID
    (15) number -> . INTEGER
    (16) number -> . FLOAT
    (17) number -> . MINUS INTEGER
    (18) number -> . MINUS FLOAT

    ID              shift and go to state 15
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    MINUS           shift and go to state 37

    number                         shift and go to state 59
    variable                       shift and go to state 60

state 58

    (13) ifelseblock -> IF boolean THEN LCURLY NEWLINE program RCURLY ELSE LCURLY . NEWLINE program RCURLY

    NEWLINE         shift and go to state 61


state 59

    (11) gaussfunc -> GAUSS LPAREN EPS DIVIDE number COMMA number . RPAREN

    RPAREN          shift and go to state 62


state 60

    (10) gaussfunc -> GAUSS LPAREN EPS DIVIDE number COMMA variable . RPAREN

    RPAREN          shift and go to state 63


state 61

    (13) ifelseblock -> IF boolean THEN LCURLY NEWLINE program RCURLY ELSE LCURLY NEWLINE . program RCURLY
    (1) program -> . program statement
    (2) program -> . statement
    (3) statement -> . random_var_assignment SEMI
    (4) statement -> . numeric_var_assignment SEMI
    (5) statement -> . ifblock
    (6) statement -> . ifelseblock
    (7) statement -> . statement NEWLINE
    (8) random_var_assignment -> . RANDOM variable EQUALS gaussfunc
    (9) numeric_var_assignment -> . NUMERIC variable EQUALS number
    (12) ifblock -> . IF boolean THEN LCURLY NEWLINE program NEWLINE RCURLY
    (13) ifelseblock -> . IF boolean THEN LCURLY NEWLINE program RCURLY ELSE LCURLY NEWLINE program RCURLY

    RANDOM          shift and go to state 7
    NUMERIC         shift and go to state 8
    IF              shift and go to state 9

    program                        shift and go to state 64
    statement                      shift and go to state 2
    random_var_assignment          shift and go to state 3
    numeric_var_assignment         shift and go to state 4
    ifblock                        shift and go to state 5
    ifelseblock                    shift and go to state 6

state 62

    (11) gaussfunc -> GAUSS LPAREN EPS DIVIDE number COMMA number RPAREN .

    SEMI            reduce using rule 11 (gaussfunc -> GAUSS LPAREN EPS DIVIDE number COMMA number RPAREN .)


state 63

    (10) gaussfunc -> GAUSS LPAREN EPS DIVIDE number COMMA variable RPAREN .

    SEMI            reduce using rule 10 (gaussfunc -> GAUSS LPAREN EPS DIVIDE number COMMA variable RPAREN .)


state 64

    (13) ifelseblock -> IF boolean THEN LCURLY NEWLINE program RCURLY ELSE LCURLY NEWLINE program . RCURLY
    (1) program -> program . statement
    (3) statement -> . random_var_assignment SEMI
    (4) statement -> . numeric_var_assignment SEMI
    (5) statement -> . ifblock
    (6) statement -> . ifelseblock
    (7) statement -> . statement NEWLINE
    (8) random_var_assignment -> . RANDOM variable EQUALS gaussfunc
    (9) numeric_var_assignment -> . NUMERIC variable EQUALS number
    (12) ifblock -> . IF boolean THEN LCURLY NEWLINE program NEWLINE RCURLY
    (13) ifelseblock -> . IF boolean THEN LCURLY NEWLINE program RCURLY ELSE LCURLY NEWLINE program RCURLY

    RCURLY          shift and go to state 65
    RANDOM          shift and go to state 7
    NUMERIC         shift and go to state 8
    IF              shift and go to state 9

    statement                      shift and go to state 10
    random_var_assignment          shift and go to state 3
    numeric_var_assignment         shift and go to state 4
    ifblock                        shift and go to state 5
    ifelseblock                    shift and go to state 6

state 65

    (13) ifelseblock -> IF boolean THEN LCURLY NEWLINE program RCURLY ELSE LCURLY NEWLINE program RCURLY .

    NEWLINE         reduce using rule 13 (ifelseblock -> IF boolean THEN LCURLY NEWLINE program RCURLY ELSE LCURLY NEWLINE program RCURLY .)
    RANDOM          reduce using rule 13 (ifelseblock -> IF boolean THEN LCURLY NEWLINE program RCURLY ELSE LCURLY NEWLINE program RCURLY .)
    NUMERIC         reduce using rule 13 (ifelseblock -> IF boolean THEN LCURLY NEWLINE program RCURLY ELSE LCURLY NEWLINE program RCURLY .)
    IF              reduce using rule 13 (ifelseblock -> IF boolean THEN LCURLY NEWLINE program RCURLY ELSE LCURLY NEWLINE program RCURLY .)
    $end            reduce using rule 13 (ifelseblock -> IF boolean THEN LCURLY NEWLINE program RCURLY ELSE LCURLY NEWLINE program RCURLY .)
    RCURLY          reduce using rule 13 (ifelseblock -> IF boolean THEN LCURLY NEWLINE program RCURLY ELSE LCURLY NEWLINE program RCURLY .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for NEWLINE in state 2 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 10 resolved as shift
WARNING: shift/reduce conflict for AND in state 31 resolved as shift
WARNING: shift/reduce conflict for OR in state 31 resolved as shift
WARNING: shift/reduce conflict for AND in state 39 resolved as shift
WARNING: shift/reduce conflict for OR in state 39 resolved as shift
WARNING: shift/reduce conflict for AND in state 40 resolved as shift
WARNING: shift/reduce conflict for OR in state 40 resolved as shift
