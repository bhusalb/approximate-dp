Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    NE
    PLUS
    POWER
    RETURN
    STRING
    TIMES

Grammar

Rule 0     S' -> program
Rule 1     program -> program statement
Rule 2     program -> statement
Rule 3     statement -> random_var_assignment SEMI
Rule 4     statement -> numeric_var_assignment SEMI
Rule 5     statement -> ifblock
Rule 6     statement -> ifelseblock
Rule 7     statement -> inputassignment SEMI
Rule 8     statement -> outputassignment SEMI
Rule 9     statement -> setoutput SEMI
Rule 10    statement -> statement NEWLINE
Rule 11    statement -> NEWLINE statement
Rule 12    inputassignment -> INPUT EQUALS LBRACKET numlist RBRACKET COMMA LBRACKET numlist RBRACKET
Rule 13    outputassignment -> OUTPUT EQUALS LBRACKET numlist RBRACKET
Rule 14    random_var_assignment -> RANDOM variable EQUALS gaussfunc
Rule 15    numeric_var_assignment -> NUMERIC variable EQUALS number
Rule 16    gaussfunc -> GAUSS LPAREN EPS DIVIDE number COMMA variable RPAREN
Rule 17    gaussfunc -> GAUSS LPAREN EPS DIVIDE number COMMA number RPAREN
Rule 18    gaussfunc -> GAUSS LPAREN EPS DIVIDE number COMMA inputindex RPAREN
Rule 19    inputindex -> INPUT LBRACKET INTEGER RBRACKET
Rule 20    setoutput -> OUTPUT LBRACKET INTEGER RBRACKET EQUALS number
Rule 21    ifblock -> IF boolean THEN LCURLY program RCURLY
Rule 22    ifelseblock -> IF boolean THEN LCURLY program RCURLY ELSE LCURLY program RCURLY
Rule 23    variable -> ID
Rule 24    numlist -> numlist COMMA number
Rule 25    numlist -> number
Rule 26    number -> INTEGER
Rule 27    number -> FLOAT
Rule 28    number -> MINUS INTEGER
Rule 29    number -> MINUS FLOAT
Rule 30    boolean -> TRUE
Rule 31    boolean -> FALSE
Rule 32    boolean -> variable GT variable
Rule 33    boolean -> variable GE variable
Rule 34    boolean -> variable LE variable
Rule 35    boolean -> variable LT variable
Rule 36    boolean -> boolean AND boolean
Rule 37    boolean -> boolean OR boolean
Rule 38    boolean -> NOT boolean

Terminals, with rules where they appear

AND                  : 36
COMMA                : 12 16 17 18 24
DIVIDE               : 16 17 18
ELSE                 : 22
EPS                  : 16 17 18
EQUALS               : 12 13 14 15 20
FALSE                : 31
FLOAT                : 27 29
GAUSS                : 16 17 18
GE                   : 33
GT                   : 32
ID                   : 23
IF                   : 21 22
INPUT                : 12 19
INTEGER              : 19 20 26 28
LBRACKET             : 12 12 13 19 20
LCURLY               : 21 22 22
LE                   : 34
LPAREN               : 16 17 18
LT                   : 35
MINUS                : 28 29
NE                   : 
NEWLINE              : 10 11
NOT                  : 38
NUMERIC              : 15
OR                   : 37
OUTPUT               : 13 20
PLUS                 : 
POWER                : 
RANDOM               : 14
RBRACKET             : 12 12 13 19 20
RCURLY               : 21 22 22
RETURN               : 
RPAREN               : 16 17 18
SEMI                 : 3 4 7 8 9
STRING               : 
THEN                 : 21 22
TIMES                : 
TRUE                 : 30
error                : 

Nonterminals, with rules where they appear

boolean              : 21 22 36 36 37 37 38
gaussfunc            : 14
ifblock              : 5
ifelseblock          : 6
inputassignment      : 7
inputindex           : 18
number               : 15 16 17 17 18 20 24 25
numeric_var_assignment : 4
numlist              : 12 12 13 24
outputassignment     : 8
program              : 1 21 22 22 0
random_var_assignment : 3
setoutput            : 9
statement            : 1 2 10 11
variable             : 14 15 16 32 32 33 33 34 34 35 35

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . program statement
    (2) program -> . statement
    (3) statement -> . random_var_assignment SEMI
    (4) statement -> . numeric_var_assignment SEMI
    (5) statement -> . ifblock
    (6) statement -> . ifelseblock
    (7) statement -> . inputassignment SEMI
    (8) statement -> . outputassignment SEMI
    (9) statement -> . setoutput SEMI
    (10) statement -> . statement NEWLINE
    (11) statement -> . NEWLINE statement
    (14) random_var_assignment -> . RANDOM variable EQUALS gaussfunc
    (15) numeric_var_assignment -> . NUMERIC variable EQUALS number
    (21) ifblock -> . IF boolean THEN LCURLY program RCURLY
    (22) ifelseblock -> . IF boolean THEN LCURLY program RCURLY ELSE LCURLY program RCURLY
    (12) inputassignment -> . INPUT EQUALS LBRACKET numlist RBRACKET COMMA LBRACKET numlist RBRACKET
    (13) outputassignment -> . OUTPUT EQUALS LBRACKET numlist RBRACKET
    (20) setoutput -> . OUTPUT LBRACKET INTEGER RBRACKET EQUALS number

    NEWLINE         shift and go to state 10
    RANDOM          shift and go to state 11
    NUMERIC         shift and go to state 12
    IF              shift and go to state 13
    INPUT           shift and go to state 14
    OUTPUT          shift and go to state 15

    program                        shift and go to state 1
    statement                      shift and go to state 2
    random_var_assignment          shift and go to state 3
    numeric_var_assignment         shift and go to state 4
    ifblock                        shift and go to state 5
    ifelseblock                    shift and go to state 6
    inputassignment                shift and go to state 7
    outputassignment               shift and go to state 8
    setoutput                      shift and go to state 9

state 1

    (0) S' -> program .
    (1) program -> program . statement
    (3) statement -> . random_var_assignment SEMI
    (4) statement -> . numeric_var_assignment SEMI
    (5) statement -> . ifblock
    (6) statement -> . ifelseblock
    (7) statement -> . inputassignment SEMI
    (8) statement -> . outputassignment SEMI
    (9) statement -> . setoutput SEMI
    (10) statement -> . statement NEWLINE
    (11) statement -> . NEWLINE statement
    (14) random_var_assignment -> . RANDOM variable EQUALS gaussfunc
    (15) numeric_var_assignment -> . NUMERIC variable EQUALS number
    (21) ifblock -> . IF boolean THEN LCURLY program RCURLY
    (22) ifelseblock -> . IF boolean THEN LCURLY program RCURLY ELSE LCURLY program RCURLY
    (12) inputassignment -> . INPUT EQUALS LBRACKET numlist RBRACKET COMMA LBRACKET numlist RBRACKET
    (13) outputassignment -> . OUTPUT EQUALS LBRACKET numlist RBRACKET
    (20) setoutput -> . OUTPUT LBRACKET INTEGER RBRACKET EQUALS number

    NEWLINE         shift and go to state 10
    RANDOM          shift and go to state 11
    NUMERIC         shift and go to state 12
    IF              shift and go to state 13
    INPUT           shift and go to state 14
    OUTPUT          shift and go to state 15

    statement                      shift and go to state 16
    random_var_assignment          shift and go to state 3
    numeric_var_assignment         shift and go to state 4
    ifblock                        shift and go to state 5
    ifelseblock                    shift and go to state 6
    inputassignment                shift and go to state 7
    outputassignment               shift and go to state 8
    setoutput                      shift and go to state 9

state 2

    (2) program -> statement .
    (10) statement -> statement . NEWLINE

  ! shift/reduce conflict for NEWLINE resolved as shift
    RANDOM          reduce using rule 2 (program -> statement .)
    NUMERIC         reduce using rule 2 (program -> statement .)
    IF              reduce using rule 2 (program -> statement .)
    INPUT           reduce using rule 2 (program -> statement .)
    OUTPUT          reduce using rule 2 (program -> statement .)
    $end            reduce using rule 2 (program -> statement .)
    RCURLY          reduce using rule 2 (program -> statement .)
    NEWLINE         shift and go to state 17

  ! NEWLINE         [ reduce using rule 2 (program -> statement .) ]


state 3

    (3) statement -> random_var_assignment . SEMI

    SEMI            shift and go to state 18


state 4

    (4) statement -> numeric_var_assignment . SEMI

    SEMI            shift and go to state 19


state 5

    (5) statement -> ifblock .

    NEWLINE         reduce using rule 5 (statement -> ifblock .)
    RANDOM          reduce using rule 5 (statement -> ifblock .)
    NUMERIC         reduce using rule 5 (statement -> ifblock .)
    IF              reduce using rule 5 (statement -> ifblock .)
    INPUT           reduce using rule 5 (statement -> ifblock .)
    OUTPUT          reduce using rule 5 (statement -> ifblock .)
    $end            reduce using rule 5 (statement -> ifblock .)
    RCURLY          reduce using rule 5 (statement -> ifblock .)


state 6

    (6) statement -> ifelseblock .

    NEWLINE         reduce using rule 6 (statement -> ifelseblock .)
    RANDOM          reduce using rule 6 (statement -> ifelseblock .)
    NUMERIC         reduce using rule 6 (statement -> ifelseblock .)
    IF              reduce using rule 6 (statement -> ifelseblock .)
    INPUT           reduce using rule 6 (statement -> ifelseblock .)
    OUTPUT          reduce using rule 6 (statement -> ifelseblock .)
    $end            reduce using rule 6 (statement -> ifelseblock .)
    RCURLY          reduce using rule 6 (statement -> ifelseblock .)


state 7

    (7) statement -> inputassignment . SEMI

    SEMI            shift and go to state 20


state 8

    (8) statement -> outputassignment . SEMI

    SEMI            shift and go to state 21


state 9

    (9) statement -> setoutput . SEMI

    SEMI            shift and go to state 22


state 10

    (11) statement -> NEWLINE . statement
    (3) statement -> . random_var_assignment SEMI
    (4) statement -> . numeric_var_assignment SEMI
    (5) statement -> . ifblock
    (6) statement -> . ifelseblock
    (7) statement -> . inputassignment SEMI
    (8) statement -> . outputassignment SEMI
    (9) statement -> . setoutput SEMI
    (10) statement -> . statement NEWLINE
    (11) statement -> . NEWLINE statement
    (14) random_var_assignment -> . RANDOM variable EQUALS gaussfunc
    (15) numeric_var_assignment -> . NUMERIC variable EQUALS number
    (21) ifblock -> . IF boolean THEN LCURLY program RCURLY
    (22) ifelseblock -> . IF boolean THEN LCURLY program RCURLY ELSE LCURLY program RCURLY
    (12) inputassignment -> . INPUT EQUALS LBRACKET numlist RBRACKET COMMA LBRACKET numlist RBRACKET
    (13) outputassignment -> . OUTPUT EQUALS LBRACKET numlist RBRACKET
    (20) setoutput -> . OUTPUT LBRACKET INTEGER RBRACKET EQUALS number

    NEWLINE         shift and go to state 10
    RANDOM          shift and go to state 11
    NUMERIC         shift and go to state 12
    IF              shift and go to state 13
    INPUT           shift and go to state 14
    OUTPUT          shift and go to state 15

    statement                      shift and go to state 23
    random_var_assignment          shift and go to state 3
    numeric_var_assignment         shift and go to state 4
    ifblock                        shift and go to state 5
    ifelseblock                    shift and go to state 6
    inputassignment                shift and go to state 7
    outputassignment               shift and go to state 8
    setoutput                      shift and go to state 9

state 11

    (14) random_var_assignment -> RANDOM . variable EQUALS gaussfunc
    (23) variable -> . ID

    ID              shift and go to state 25

    variable                       shift and go to state 24

state 12

    (15) numeric_var_assignment -> NUMERIC . variable EQUALS number
    (23) variable -> . ID

    ID              shift and go to state 25

    variable                       shift and go to state 26

state 13

    (21) ifblock -> IF . boolean THEN LCURLY program RCURLY
    (22) ifelseblock -> IF . boolean THEN LCURLY program RCURLY ELSE LCURLY program RCURLY
    (30) boolean -> . TRUE
    (31) boolean -> . FALSE
    (32) boolean -> . variable GT variable
    (33) boolean -> . variable GE variable
    (34) boolean -> . variable LE variable
    (35) boolean -> . variable LT variable
    (36) boolean -> . boolean AND boolean
    (37) boolean -> . boolean OR boolean
    (38) boolean -> . NOT boolean
    (23) variable -> . ID

    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    NOT             shift and go to state 31
    ID              shift and go to state 25

    boolean                        shift and go to state 27
    variable                       shift and go to state 30

state 14

    (12) inputassignment -> INPUT . EQUALS LBRACKET numlist RBRACKET COMMA LBRACKET numlist RBRACKET

    EQUALS          shift and go to state 32


state 15

    (13) outputassignment -> OUTPUT . EQUALS LBRACKET numlist RBRACKET
    (20) setoutput -> OUTPUT . LBRACKET INTEGER RBRACKET EQUALS number

    EQUALS          shift and go to state 33
    LBRACKET        shift and go to state 34


state 16

    (1) program -> program statement .
    (10) statement -> statement . NEWLINE

  ! shift/reduce conflict for NEWLINE resolved as shift
    RANDOM          reduce using rule 1 (program -> program statement .)
    NUMERIC         reduce using rule 1 (program -> program statement .)
    IF              reduce using rule 1 (program -> program statement .)
    INPUT           reduce using rule 1 (program -> program statement .)
    OUTPUT          reduce using rule 1 (program -> program statement .)
    $end            reduce using rule 1 (program -> program statement .)
    RCURLY          reduce using rule 1 (program -> program statement .)
    NEWLINE         shift and go to state 17

  ! NEWLINE         [ reduce using rule 1 (program -> program statement .) ]


state 17

    (10) statement -> statement NEWLINE .

    NEWLINE         reduce using rule 10 (statement -> statement NEWLINE .)
    RANDOM          reduce using rule 10 (statement -> statement NEWLINE .)
    NUMERIC         reduce using rule 10 (statement -> statement NEWLINE .)
    IF              reduce using rule 10 (statement -> statement NEWLINE .)
    INPUT           reduce using rule 10 (statement -> statement NEWLINE .)
    OUTPUT          reduce using rule 10 (statement -> statement NEWLINE .)
    $end            reduce using rule 10 (statement -> statement NEWLINE .)
    RCURLY          reduce using rule 10 (statement -> statement NEWLINE .)


state 18

    (3) statement -> random_var_assignment SEMI .

    NEWLINE         reduce using rule 3 (statement -> random_var_assignment SEMI .)
    RANDOM          reduce using rule 3 (statement -> random_var_assignment SEMI .)
    NUMERIC         reduce using rule 3 (statement -> random_var_assignment SEMI .)
    IF              reduce using rule 3 (statement -> random_var_assignment SEMI .)
    INPUT           reduce using rule 3 (statement -> random_var_assignment SEMI .)
    OUTPUT          reduce using rule 3 (statement -> random_var_assignment SEMI .)
    $end            reduce using rule 3 (statement -> random_var_assignment SEMI .)
    RCURLY          reduce using rule 3 (statement -> random_var_assignment SEMI .)


state 19

    (4) statement -> numeric_var_assignment SEMI .

    NEWLINE         reduce using rule 4 (statement -> numeric_var_assignment SEMI .)
    RANDOM          reduce using rule 4 (statement -> numeric_var_assignment SEMI .)
    NUMERIC         reduce using rule 4 (statement -> numeric_var_assignment SEMI .)
    IF              reduce using rule 4 (statement -> numeric_var_assignment SEMI .)
    INPUT           reduce using rule 4 (statement -> numeric_var_assignment SEMI .)
    OUTPUT          reduce using rule 4 (statement -> numeric_var_assignment SEMI .)
    $end            reduce using rule 4 (statement -> numeric_var_assignment SEMI .)
    RCURLY          reduce using rule 4 (statement -> numeric_var_assignment SEMI .)


state 20

    (7) statement -> inputassignment SEMI .

    NEWLINE         reduce using rule 7 (statement -> inputassignment SEMI .)
    RANDOM          reduce using rule 7 (statement -> inputassignment SEMI .)
    NUMERIC         reduce using rule 7 (statement -> inputassignment SEMI .)
    IF              reduce using rule 7 (statement -> inputassignment SEMI .)
    INPUT           reduce using rule 7 (statement -> inputassignment SEMI .)
    OUTPUT          reduce using rule 7 (statement -> inputassignment SEMI .)
    $end            reduce using rule 7 (statement -> inputassignment SEMI .)
    RCURLY          reduce using rule 7 (statement -> inputassignment SEMI .)


state 21

    (8) statement -> outputassignment SEMI .

    NEWLINE         reduce using rule 8 (statement -> outputassignment SEMI .)
    RANDOM          reduce using rule 8 (statement -> outputassignment SEMI .)
    NUMERIC         reduce using rule 8 (statement -> outputassignment SEMI .)
    IF              reduce using rule 8 (statement -> outputassignment SEMI .)
    INPUT           reduce using rule 8 (statement -> outputassignment SEMI .)
    OUTPUT          reduce using rule 8 (statement -> outputassignment SEMI .)
    $end            reduce using rule 8 (statement -> outputassignment SEMI .)
    RCURLY          reduce using rule 8 (statement -> outputassignment SEMI .)


state 22

    (9) statement -> setoutput SEMI .

    NEWLINE         reduce using rule 9 (statement -> setoutput SEMI .)
    RANDOM          reduce using rule 9 (statement -> setoutput SEMI .)
    NUMERIC         reduce using rule 9 (statement -> setoutput SEMI .)
    IF              reduce using rule 9 (statement -> setoutput SEMI .)
    INPUT           reduce using rule 9 (statement -> setoutput SEMI .)
    OUTPUT          reduce using rule 9 (statement -> setoutput SEMI .)
    $end            reduce using rule 9 (statement -> setoutput SEMI .)
    RCURLY          reduce using rule 9 (statement -> setoutput SEMI .)


state 23

    (11) statement -> NEWLINE statement .
    (10) statement -> statement . NEWLINE

  ! shift/reduce conflict for NEWLINE resolved as shift
    RANDOM          reduce using rule 11 (statement -> NEWLINE statement .)
    NUMERIC         reduce using rule 11 (statement -> NEWLINE statement .)
    IF              reduce using rule 11 (statement -> NEWLINE statement .)
    INPUT           reduce using rule 11 (statement -> NEWLINE statement .)
    OUTPUT          reduce using rule 11 (statement -> NEWLINE statement .)
    $end            reduce using rule 11 (statement -> NEWLINE statement .)
    RCURLY          reduce using rule 11 (statement -> NEWLINE statement .)
    NEWLINE         shift and go to state 17

  ! NEWLINE         [ reduce using rule 11 (statement -> NEWLINE statement .) ]


state 24

    (14) random_var_assignment -> RANDOM variable . EQUALS gaussfunc

    EQUALS          shift and go to state 35


state 25

    (23) variable -> ID .

    EQUALS          reduce using rule 23 (variable -> ID .)
    GT              reduce using rule 23 (variable -> ID .)
    GE              reduce using rule 23 (variable -> ID .)
    LE              reduce using rule 23 (variable -> ID .)
    LT              reduce using rule 23 (variable -> ID .)
    THEN            reduce using rule 23 (variable -> ID .)
    AND             reduce using rule 23 (variable -> ID .)
    OR              reduce using rule 23 (variable -> ID .)
    RPAREN          reduce using rule 23 (variable -> ID .)


state 26

    (15) numeric_var_assignment -> NUMERIC variable . EQUALS number

    EQUALS          shift and go to state 36


state 27

    (21) ifblock -> IF boolean . THEN LCURLY program RCURLY
    (22) ifelseblock -> IF boolean . THEN LCURLY program RCURLY ELSE LCURLY program RCURLY
    (36) boolean -> boolean . AND boolean
    (37) boolean -> boolean . OR boolean

    THEN            shift and go to state 37
    AND             shift and go to state 38
    OR              shift and go to state 39


state 28

    (30) boolean -> TRUE .

    THEN            reduce using rule 30 (boolean -> TRUE .)
    AND             reduce using rule 30 (boolean -> TRUE .)
    OR              reduce using rule 30 (boolean -> TRUE .)


state 29

    (31) boolean -> FALSE .

    THEN            reduce using rule 31 (boolean -> FALSE .)
    AND             reduce using rule 31 (boolean -> FALSE .)
    OR              reduce using rule 31 (boolean -> FALSE .)


state 30

    (32) boolean -> variable . GT variable
    (33) boolean -> variable . GE variable
    (34) boolean -> variable . LE variable
    (35) boolean -> variable . LT variable

    GT              shift and go to state 40
    GE              shift and go to state 41
    LE              shift and go to state 42
    LT              shift and go to state 43


state 31

    (38) boolean -> NOT . boolean
    (30) boolean -> . TRUE
    (31) boolean -> . FALSE
    (32) boolean -> . variable GT variable
    (33) boolean -> . variable GE variable
    (34) boolean -> . variable LE variable
    (35) boolean -> . variable LT variable
    (36) boolean -> . boolean AND boolean
    (37) boolean -> . boolean OR boolean
    (38) boolean -> . NOT boolean
    (23) variable -> . ID

    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    NOT             shift and go to state 31
    ID              shift and go to state 25

    boolean                        shift and go to state 44
    variable                       shift and go to state 30

state 32

    (12) inputassignment -> INPUT EQUALS . LBRACKET numlist RBRACKET COMMA LBRACKET numlist RBRACKET

    LBRACKET        shift and go to state 45


state 33

    (13) outputassignment -> OUTPUT EQUALS . LBRACKET numlist RBRACKET

    LBRACKET        shift and go to state 46


state 34

    (20) setoutput -> OUTPUT LBRACKET . INTEGER RBRACKET EQUALS number

    INTEGER         shift and go to state 47


state 35

    (14) random_var_assignment -> RANDOM variable EQUALS . gaussfunc
    (16) gaussfunc -> . GAUSS LPAREN EPS DIVIDE number COMMA variable RPAREN
    (17) gaussfunc -> . GAUSS LPAREN EPS DIVIDE number COMMA number RPAREN
    (18) gaussfunc -> . GAUSS LPAREN EPS DIVIDE number COMMA inputindex RPAREN

    GAUSS           shift and go to state 49

    gaussfunc                      shift and go to state 48

state 36

    (15) numeric_var_assignment -> NUMERIC variable EQUALS . number
    (26) number -> . INTEGER
    (27) number -> . FLOAT
    (28) number -> . MINUS INTEGER
    (29) number -> . MINUS FLOAT

    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    MINUS           shift and go to state 53

    number                         shift and go to state 50

state 37

    (21) ifblock -> IF boolean THEN . LCURLY program RCURLY
    (22) ifelseblock -> IF boolean THEN . LCURLY program RCURLY ELSE LCURLY program RCURLY

    LCURLY          shift and go to state 54


state 38

    (36) boolean -> boolean AND . boolean
    (30) boolean -> . TRUE
    (31) boolean -> . FALSE
    (32) boolean -> . variable GT variable
    (33) boolean -> . variable GE variable
    (34) boolean -> . variable LE variable
    (35) boolean -> . variable LT variable
    (36) boolean -> . boolean AND boolean
    (37) boolean -> . boolean OR boolean
    (38) boolean -> . NOT boolean
    (23) variable -> . ID

    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    NOT             shift and go to state 31
    ID              shift and go to state 25

    boolean                        shift and go to state 55
    variable                       shift and go to state 30

state 39

    (37) boolean -> boolean OR . boolean
    (30) boolean -> . TRUE
    (31) boolean -> . FALSE
    (32) boolean -> . variable GT variable
    (33) boolean -> . variable GE variable
    (34) boolean -> . variable LE variable
    (35) boolean -> . variable LT variable
    (36) boolean -> . boolean AND boolean
    (37) boolean -> . boolean OR boolean
    (38) boolean -> . NOT boolean
    (23) variable -> . ID

    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    NOT             shift and go to state 31
    ID              shift and go to state 25

    boolean                        shift and go to state 56
    variable                       shift and go to state 30

state 40

    (32) boolean -> variable GT . variable
    (23) variable -> . ID

    ID              shift and go to state 25

    variable                       shift and go to state 57

state 41

    (33) boolean -> variable GE . variable
    (23) variable -> . ID

    ID              shift and go to state 25

    variable                       shift and go to state 58

state 42

    (34) boolean -> variable LE . variable
    (23) variable -> . ID

    ID              shift and go to state 25

    variable                       shift and go to state 59

state 43

    (35) boolean -> variable LT . variable
    (23) variable -> . ID

    ID              shift and go to state 25

    variable                       shift and go to state 60

state 44

    (38) boolean -> NOT boolean .
    (36) boolean -> boolean . AND boolean
    (37) boolean -> boolean . OR boolean

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    THEN            reduce using rule 38 (boolean -> NOT boolean .)
    AND             shift and go to state 38
    OR              shift and go to state 39

  ! AND             [ reduce using rule 38 (boolean -> NOT boolean .) ]
  ! OR              [ reduce using rule 38 (boolean -> NOT boolean .) ]


state 45

    (12) inputassignment -> INPUT EQUALS LBRACKET . numlist RBRACKET COMMA LBRACKET numlist RBRACKET
    (24) numlist -> . numlist COMMA number
    (25) numlist -> . number
    (26) number -> . INTEGER
    (27) number -> . FLOAT
    (28) number -> . MINUS INTEGER
    (29) number -> . MINUS FLOAT

    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    MINUS           shift and go to state 53

    numlist                        shift and go to state 61
    number                         shift and go to state 62

state 46

    (13) outputassignment -> OUTPUT EQUALS LBRACKET . numlist RBRACKET
    (24) numlist -> . numlist COMMA number
    (25) numlist -> . number
    (26) number -> . INTEGER
    (27) number -> . FLOAT
    (28) number -> . MINUS INTEGER
    (29) number -> . MINUS FLOAT

    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    MINUS           shift and go to state 53

    numlist                        shift and go to state 63
    number                         shift and go to state 62

state 47

    (20) setoutput -> OUTPUT LBRACKET INTEGER . RBRACKET EQUALS number

    RBRACKET        shift and go to state 64


state 48

    (14) random_var_assignment -> RANDOM variable EQUALS gaussfunc .

    SEMI            reduce using rule 14 (random_var_assignment -> RANDOM variable EQUALS gaussfunc .)


state 49

    (16) gaussfunc -> GAUSS . LPAREN EPS DIVIDE number COMMA variable RPAREN
    (17) gaussfunc -> GAUSS . LPAREN EPS DIVIDE number COMMA number RPAREN
    (18) gaussfunc -> GAUSS . LPAREN EPS DIVIDE number COMMA inputindex RPAREN

    LPAREN          shift and go to state 65


state 50

    (15) numeric_var_assignment -> NUMERIC variable EQUALS number .

    SEMI            reduce using rule 15 (numeric_var_assignment -> NUMERIC variable EQUALS number .)


state 51

    (26) number -> INTEGER .

    SEMI            reduce using rule 26 (number -> INTEGER .)
    RBRACKET        reduce using rule 26 (number -> INTEGER .)
    COMMA           reduce using rule 26 (number -> INTEGER .)
    RPAREN          reduce using rule 26 (number -> INTEGER .)


state 52

    (27) number -> FLOAT .

    SEMI            reduce using rule 27 (number -> FLOAT .)
    RBRACKET        reduce using rule 27 (number -> FLOAT .)
    COMMA           reduce using rule 27 (number -> FLOAT .)
    RPAREN          reduce using rule 27 (number -> FLOAT .)


state 53

    (28) number -> MINUS . INTEGER
    (29) number -> MINUS . FLOAT

    INTEGER         shift and go to state 66
    FLOAT           shift and go to state 67


state 54

    (21) ifblock -> IF boolean THEN LCURLY . program RCURLY
    (22) ifelseblock -> IF boolean THEN LCURLY . program RCURLY ELSE LCURLY program RCURLY
    (1) program -> . program statement
    (2) program -> . statement
    (3) statement -> . random_var_assignment SEMI
    (4) statement -> . numeric_var_assignment SEMI
    (5) statement -> . ifblock
    (6) statement -> . ifelseblock
    (7) statement -> . inputassignment SEMI
    (8) statement -> . outputassignment SEMI
    (9) statement -> . setoutput SEMI
    (10) statement -> . statement NEWLINE
    (11) statement -> . NEWLINE statement
    (14) random_var_assignment -> . RANDOM variable EQUALS gaussfunc
    (15) numeric_var_assignment -> . NUMERIC variable EQUALS number
    (21) ifblock -> . IF boolean THEN LCURLY program RCURLY
    (22) ifelseblock -> . IF boolean THEN LCURLY program RCURLY ELSE LCURLY program RCURLY
    (12) inputassignment -> . INPUT EQUALS LBRACKET numlist RBRACKET COMMA LBRACKET numlist RBRACKET
    (13) outputassignment -> . OUTPUT EQUALS LBRACKET numlist RBRACKET
    (20) setoutput -> . OUTPUT LBRACKET INTEGER RBRACKET EQUALS number

    NEWLINE         shift and go to state 10
    RANDOM          shift and go to state 11
    NUMERIC         shift and go to state 12
    IF              shift and go to state 13
    INPUT           shift and go to state 14
    OUTPUT          shift and go to state 15

    program                        shift and go to state 68
    statement                      shift and go to state 2
    random_var_assignment          shift and go to state 3
    numeric_var_assignment         shift and go to state 4
    ifblock                        shift and go to state 5
    ifelseblock                    shift and go to state 6
    inputassignment                shift and go to state 7
    outputassignment               shift and go to state 8
    setoutput                      shift and go to state 9

state 55

    (36) boolean -> boolean AND boolean .
    (36) boolean -> boolean . AND boolean
    (37) boolean -> boolean . OR boolean

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    THEN            reduce using rule 36 (boolean -> boolean AND boolean .)
    AND             shift and go to state 38
    OR              shift and go to state 39

  ! AND             [ reduce using rule 36 (boolean -> boolean AND boolean .) ]
  ! OR              [ reduce using rule 36 (boolean -> boolean AND boolean .) ]


state 56

    (37) boolean -> boolean OR boolean .
    (36) boolean -> boolean . AND boolean
    (37) boolean -> boolean . OR boolean

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    THEN            reduce using rule 37 (boolean -> boolean OR boolean .)
    AND             shift and go to state 38
    OR              shift and go to state 39

  ! AND             [ reduce using rule 37 (boolean -> boolean OR boolean .) ]
  ! OR              [ reduce using rule 37 (boolean -> boolean OR boolean .) ]


state 57

    (32) boolean -> variable GT variable .

    THEN            reduce using rule 32 (boolean -> variable GT variable .)
    AND             reduce using rule 32 (boolean -> variable GT variable .)
    OR              reduce using rule 32 (boolean -> variable GT variable .)


state 58

    (33) boolean -> variable GE variable .

    THEN            reduce using rule 33 (boolean -> variable GE variable .)
    AND             reduce using rule 33 (boolean -> variable GE variable .)
    OR              reduce using rule 33 (boolean -> variable GE variable .)


state 59

    (34) boolean -> variable LE variable .

    THEN            reduce using rule 34 (boolean -> variable LE variable .)
    AND             reduce using rule 34 (boolean -> variable LE variable .)
    OR              reduce using rule 34 (boolean -> variable LE variable .)


state 60

    (35) boolean -> variable LT variable .

    THEN            reduce using rule 35 (boolean -> variable LT variable .)
    AND             reduce using rule 35 (boolean -> variable LT variable .)
    OR              reduce using rule 35 (boolean -> variable LT variable .)


state 61

    (12) inputassignment -> INPUT EQUALS LBRACKET numlist . RBRACKET COMMA LBRACKET numlist RBRACKET
    (24) numlist -> numlist . COMMA number

    RBRACKET        shift and go to state 69
    COMMA           shift and go to state 70


state 62

    (25) numlist -> number .

    RBRACKET        reduce using rule 25 (numlist -> number .)
    COMMA           reduce using rule 25 (numlist -> number .)


state 63

    (13) outputassignment -> OUTPUT EQUALS LBRACKET numlist . RBRACKET
    (24) numlist -> numlist . COMMA number

    RBRACKET        shift and go to state 71
    COMMA           shift and go to state 70


state 64

    (20) setoutput -> OUTPUT LBRACKET INTEGER RBRACKET . EQUALS number

    EQUALS          shift and go to state 72


state 65

    (16) gaussfunc -> GAUSS LPAREN . EPS DIVIDE number COMMA variable RPAREN
    (17) gaussfunc -> GAUSS LPAREN . EPS DIVIDE number COMMA number RPAREN
    (18) gaussfunc -> GAUSS LPAREN . EPS DIVIDE number COMMA inputindex RPAREN

    EPS             shift and go to state 73


state 66

    (28) number -> MINUS INTEGER .

    SEMI            reduce using rule 28 (number -> MINUS INTEGER .)
    RBRACKET        reduce using rule 28 (number -> MINUS INTEGER .)
    COMMA           reduce using rule 28 (number -> MINUS INTEGER .)
    RPAREN          reduce using rule 28 (number -> MINUS INTEGER .)


state 67

    (29) number -> MINUS FLOAT .

    SEMI            reduce using rule 29 (number -> MINUS FLOAT .)
    RBRACKET        reduce using rule 29 (number -> MINUS FLOAT .)
    COMMA           reduce using rule 29 (number -> MINUS FLOAT .)
    RPAREN          reduce using rule 29 (number -> MINUS FLOAT .)


state 68

    (21) ifblock -> IF boolean THEN LCURLY program . RCURLY
    (22) ifelseblock -> IF boolean THEN LCURLY program . RCURLY ELSE LCURLY program RCURLY
    (1) program -> program . statement
    (3) statement -> . random_var_assignment SEMI
    (4) statement -> . numeric_var_assignment SEMI
    (5) statement -> . ifblock
    (6) statement -> . ifelseblock
    (7) statement -> . inputassignment SEMI
    (8) statement -> . outputassignment SEMI
    (9) statement -> . setoutput SEMI
    (10) statement -> . statement NEWLINE
    (11) statement -> . NEWLINE statement
    (14) random_var_assignment -> . RANDOM variable EQUALS gaussfunc
    (15) numeric_var_assignment -> . NUMERIC variable EQUALS number
    (21) ifblock -> . IF boolean THEN LCURLY program RCURLY
    (22) ifelseblock -> . IF boolean THEN LCURLY program RCURLY ELSE LCURLY program RCURLY
    (12) inputassignment -> . INPUT EQUALS LBRACKET numlist RBRACKET COMMA LBRACKET numlist RBRACKET
    (13) outputassignment -> . OUTPUT EQUALS LBRACKET numlist RBRACKET
    (20) setoutput -> . OUTPUT LBRACKET INTEGER RBRACKET EQUALS number

    RCURLY          shift and go to state 74
    NEWLINE         shift and go to state 10
    RANDOM          shift and go to state 11
    NUMERIC         shift and go to state 12
    IF              shift and go to state 13
    INPUT           shift and go to state 14
    OUTPUT          shift and go to state 15

    statement                      shift and go to state 16
    random_var_assignment          shift and go to state 3
    numeric_var_assignment         shift and go to state 4
    ifblock                        shift and go to state 5
    ifelseblock                    shift and go to state 6
    inputassignment                shift and go to state 7
    outputassignment               shift and go to state 8
    setoutput                      shift and go to state 9

state 69

    (12) inputassignment -> INPUT EQUALS LBRACKET numlist RBRACKET . COMMA LBRACKET numlist RBRACKET

    COMMA           shift and go to state 75


state 70

    (24) numlist -> numlist COMMA . number
    (26) number -> . INTEGER
    (27) number -> . FLOAT
    (28) number -> . MINUS INTEGER
    (29) number -> . MINUS FLOAT

    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    MINUS           shift and go to state 53

    number                         shift and go to state 76

state 71

    (13) outputassignment -> OUTPUT EQUALS LBRACKET numlist RBRACKET .

    SEMI            reduce using rule 13 (outputassignment -> OUTPUT EQUALS LBRACKET numlist RBRACKET .)


state 72

    (20) setoutput -> OUTPUT LBRACKET INTEGER RBRACKET EQUALS . number
    (26) number -> . INTEGER
    (27) number -> . FLOAT
    (28) number -> . MINUS INTEGER
    (29) number -> . MINUS FLOAT

    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    MINUS           shift and go to state 53

    number                         shift and go to state 77

state 73

    (16) gaussfunc -> GAUSS LPAREN EPS . DIVIDE number COMMA variable RPAREN
    (17) gaussfunc -> GAUSS LPAREN EPS . DIVIDE number COMMA number RPAREN
    (18) gaussfunc -> GAUSS LPAREN EPS . DIVIDE number COMMA inputindex RPAREN

    DIVIDE          shift and go to state 78


state 74

    (21) ifblock -> IF boolean THEN LCURLY program RCURLY .
    (22) ifelseblock -> IF boolean THEN LCURLY program RCURLY . ELSE LCURLY program RCURLY

    NEWLINE         reduce using rule 21 (ifblock -> IF boolean THEN LCURLY program RCURLY .)
    RANDOM          reduce using rule 21 (ifblock -> IF boolean THEN LCURLY program RCURLY .)
    NUMERIC         reduce using rule 21 (ifblock -> IF boolean THEN LCURLY program RCURLY .)
    IF              reduce using rule 21 (ifblock -> IF boolean THEN LCURLY program RCURLY .)
    INPUT           reduce using rule 21 (ifblock -> IF boolean THEN LCURLY program RCURLY .)
    OUTPUT          reduce using rule 21 (ifblock -> IF boolean THEN LCURLY program RCURLY .)
    $end            reduce using rule 21 (ifblock -> IF boolean THEN LCURLY program RCURLY .)
    RCURLY          reduce using rule 21 (ifblock -> IF boolean THEN LCURLY program RCURLY .)
    ELSE            shift and go to state 79


state 75

    (12) inputassignment -> INPUT EQUALS LBRACKET numlist RBRACKET COMMA . LBRACKET numlist RBRACKET

    LBRACKET        shift and go to state 80


state 76

    (24) numlist -> numlist COMMA number .

    RBRACKET        reduce using rule 24 (numlist -> numlist COMMA number .)
    COMMA           reduce using rule 24 (numlist -> numlist COMMA number .)


state 77

    (20) setoutput -> OUTPUT LBRACKET INTEGER RBRACKET EQUALS number .

    SEMI            reduce using rule 20 (setoutput -> OUTPUT LBRACKET INTEGER RBRACKET EQUALS number .)


state 78

    (16) gaussfunc -> GAUSS LPAREN EPS DIVIDE . number COMMA variable RPAREN
    (17) gaussfunc -> GAUSS LPAREN EPS DIVIDE . number COMMA number RPAREN
    (18) gaussfunc -> GAUSS LPAREN EPS DIVIDE . number COMMA inputindex RPAREN
    (26) number -> . INTEGER
    (27) number -> . FLOAT
    (28) number -> . MINUS INTEGER
    (29) number -> . MINUS FLOAT

    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    MINUS           shift and go to state 53

    number                         shift and go to state 81

state 79

    (22) ifelseblock -> IF boolean THEN LCURLY program RCURLY ELSE . LCURLY program RCURLY

    LCURLY          shift and go to state 82


state 80

    (12) inputassignment -> INPUT EQUALS LBRACKET numlist RBRACKET COMMA LBRACKET . numlist RBRACKET
    (24) numlist -> . numlist COMMA number
    (25) numlist -> . number
    (26) number -> . INTEGER
    (27) number -> . FLOAT
    (28) number -> . MINUS INTEGER
    (29) number -> . MINUS FLOAT

    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    MINUS           shift and go to state 53

    numlist                        shift and go to state 83
    number                         shift and go to state 62

state 81

    (16) gaussfunc -> GAUSS LPAREN EPS DIVIDE number . COMMA variable RPAREN
    (17) gaussfunc -> GAUSS LPAREN EPS DIVIDE number . COMMA number RPAREN
    (18) gaussfunc -> GAUSS LPAREN EPS DIVIDE number . COMMA inputindex RPAREN

    COMMA           shift and go to state 84


state 82

    (22) ifelseblock -> IF boolean THEN LCURLY program RCURLY ELSE LCURLY . program RCURLY
    (1) program -> . program statement
    (2) program -> . statement
    (3) statement -> . random_var_assignment SEMI
    (4) statement -> . numeric_var_assignment SEMI
    (5) statement -> . ifblock
    (6) statement -> . ifelseblock
    (7) statement -> . inputassignment SEMI
    (8) statement -> . outputassignment SEMI
    (9) statement -> . setoutput SEMI
    (10) statement -> . statement NEWLINE
    (11) statement -> . NEWLINE statement
    (14) random_var_assignment -> . RANDOM variable EQUALS gaussfunc
    (15) numeric_var_assignment -> . NUMERIC variable EQUALS number
    (21) ifblock -> . IF boolean THEN LCURLY program RCURLY
    (22) ifelseblock -> . IF boolean THEN LCURLY program RCURLY ELSE LCURLY program RCURLY
    (12) inputassignment -> . INPUT EQUALS LBRACKET numlist RBRACKET COMMA LBRACKET numlist RBRACKET
    (13) outputassignment -> . OUTPUT EQUALS LBRACKET numlist RBRACKET
    (20) setoutput -> . OUTPUT LBRACKET INTEGER RBRACKET EQUALS number

    NEWLINE         shift and go to state 10
    RANDOM          shift and go to state 11
    NUMERIC         shift and go to state 12
    IF              shift and go to state 13
    INPUT           shift and go to state 14
    OUTPUT          shift and go to state 15

    program                        shift and go to state 85
    statement                      shift and go to state 2
    random_var_assignment          shift and go to state 3
    numeric_var_assignment         shift and go to state 4
    ifblock                        shift and go to state 5
    ifelseblock                    shift and go to state 6
    inputassignment                shift and go to state 7
    outputassignment               shift and go to state 8
    setoutput                      shift and go to state 9

state 83

    (12) inputassignment -> INPUT EQUALS LBRACKET numlist RBRACKET COMMA LBRACKET numlist . RBRACKET
    (24) numlist -> numlist . COMMA number

    RBRACKET        shift and go to state 86
    COMMA           shift and go to state 70


state 84

    (16) gaussfunc -> GAUSS LPAREN EPS DIVIDE number COMMA . variable RPAREN
    (17) gaussfunc -> GAUSS LPAREN EPS DIVIDE number COMMA . number RPAREN
    (18) gaussfunc -> GAUSS LPAREN EPS DIVIDE number COMMA . inputindex RPAREN
    (23) variable -> . ID
    (26) number -> . INTEGER
    (27) number -> . FLOAT
    (28) number -> . MINUS INTEGER
    (29) number -> . MINUS FLOAT
    (19) inputindex -> . INPUT LBRACKET INTEGER RBRACKET

    ID              shift and go to state 25
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    MINUS           shift and go to state 53
    INPUT           shift and go to state 90

    number                         shift and go to state 87
    variable                       shift and go to state 88
    inputindex                     shift and go to state 89

state 85

    (22) ifelseblock -> IF boolean THEN LCURLY program RCURLY ELSE LCURLY program . RCURLY
    (1) program -> program . statement
    (3) statement -> . random_var_assignment SEMI
    (4) statement -> . numeric_var_assignment SEMI
    (5) statement -> . ifblock
    (6) statement -> . ifelseblock
    (7) statement -> . inputassignment SEMI
    (8) statement -> . outputassignment SEMI
    (9) statement -> . setoutput SEMI
    (10) statement -> . statement NEWLINE
    (11) statement -> . NEWLINE statement
    (14) random_var_assignment -> . RANDOM variable EQUALS gaussfunc
    (15) numeric_var_assignment -> . NUMERIC variable EQUALS number
    (21) ifblock -> . IF boolean THEN LCURLY program RCURLY
    (22) ifelseblock -> . IF boolean THEN LCURLY program RCURLY ELSE LCURLY program RCURLY
    (12) inputassignment -> . INPUT EQUALS LBRACKET numlist RBRACKET COMMA LBRACKET numlist RBRACKET
    (13) outputassignment -> . OUTPUT EQUALS LBRACKET numlist RBRACKET
    (20) setoutput -> . OUTPUT LBRACKET INTEGER RBRACKET EQUALS number

    RCURLY          shift and go to state 91
    NEWLINE         shift and go to state 10
    RANDOM          shift and go to state 11
    NUMERIC         shift and go to state 12
    IF              shift and go to state 13
    INPUT           shift and go to state 14
    OUTPUT          shift and go to state 15

    statement                      shift and go to state 16
    random_var_assignment          shift and go to state 3
    numeric_var_assignment         shift and go to state 4
    ifblock                        shift and go to state 5
    ifelseblock                    shift and go to state 6
    inputassignment                shift and go to state 7
    outputassignment               shift and go to state 8
    setoutput                      shift and go to state 9

state 86

    (12) inputassignment -> INPUT EQUALS LBRACKET numlist RBRACKET COMMA LBRACKET numlist RBRACKET .

    SEMI            reduce using rule 12 (inputassignment -> INPUT EQUALS LBRACKET numlist RBRACKET COMMA LBRACKET numlist RBRACKET .)


state 87

    (17) gaussfunc -> GAUSS LPAREN EPS DIVIDE number COMMA number . RPAREN

    RPAREN          shift and go to state 92


state 88

    (16) gaussfunc -> GAUSS LPAREN EPS DIVIDE number COMMA variable . RPAREN

    RPAREN          shift and go to state 93


state 89

    (18) gaussfunc -> GAUSS LPAREN EPS DIVIDE number COMMA inputindex . RPAREN

    RPAREN          shift and go to state 94


state 90

    (19) inputindex -> INPUT . LBRACKET INTEGER RBRACKET

    LBRACKET        shift and go to state 95


state 91

    (22) ifelseblock -> IF boolean THEN LCURLY program RCURLY ELSE LCURLY program RCURLY .

    NEWLINE         reduce using rule 22 (ifelseblock -> IF boolean THEN LCURLY program RCURLY ELSE LCURLY program RCURLY .)
    RANDOM          reduce using rule 22 (ifelseblock -> IF boolean THEN LCURLY program RCURLY ELSE LCURLY program RCURLY .)
    NUMERIC         reduce using rule 22 (ifelseblock -> IF boolean THEN LCURLY program RCURLY ELSE LCURLY program RCURLY .)
    IF              reduce using rule 22 (ifelseblock -> IF boolean THEN LCURLY program RCURLY ELSE LCURLY program RCURLY .)
    INPUT           reduce using rule 22 (ifelseblock -> IF boolean THEN LCURLY program RCURLY ELSE LCURLY program RCURLY .)
    OUTPUT          reduce using rule 22 (ifelseblock -> IF boolean THEN LCURLY program RCURLY ELSE LCURLY program RCURLY .)
    $end            reduce using rule 22 (ifelseblock -> IF boolean THEN LCURLY program RCURLY ELSE LCURLY program RCURLY .)
    RCURLY          reduce using rule 22 (ifelseblock -> IF boolean THEN LCURLY program RCURLY ELSE LCURLY program RCURLY .)


state 92

    (17) gaussfunc -> GAUSS LPAREN EPS DIVIDE number COMMA number RPAREN .

    SEMI            reduce using rule 17 (gaussfunc -> GAUSS LPAREN EPS DIVIDE number COMMA number RPAREN .)


state 93

    (16) gaussfunc -> GAUSS LPAREN EPS DIVIDE number COMMA variable RPAREN .

    SEMI            reduce using rule 16 (gaussfunc -> GAUSS LPAREN EPS DIVIDE number COMMA variable RPAREN .)


state 94

    (18) gaussfunc -> GAUSS LPAREN EPS DIVIDE number COMMA inputindex RPAREN .

    SEMI            reduce using rule 18 (gaussfunc -> GAUSS LPAREN EPS DIVIDE number COMMA inputindex RPAREN .)


state 95

    (19) inputindex -> INPUT LBRACKET . INTEGER RBRACKET

    INTEGER         shift and go to state 96


state 96

    (19) inputindex -> INPUT LBRACKET INTEGER . RBRACKET

    RBRACKET        shift and go to state 97


state 97

    (19) inputindex -> INPUT LBRACKET INTEGER RBRACKET .

    RPAREN          reduce using rule 19 (inputindex -> INPUT LBRACKET INTEGER RBRACKET .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for NEWLINE in state 2 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 16 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 23 resolved as shift
WARNING: shift/reduce conflict for AND in state 44 resolved as shift
WARNING: shift/reduce conflict for OR in state 44 resolved as shift
WARNING: shift/reduce conflict for AND in state 55 resolved as shift
WARNING: shift/reduce conflict for OR in state 55 resolved as shift
WARNING: shift/reduce conflict for AND in state 56 resolved as shift
WARNING: shift/reduce conflict for OR in state 56 resolved as shift
